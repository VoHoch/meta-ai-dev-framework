# Claude-Specific Implementation v1.1

## üéØ **Model-Selection-Guidelines**

### Claude Opus 4 - Optimale Phasen:
- **Phase 1:** Konzeption & Anforderungsanalyse
  - Komplexe Dom√§nen-Analyse
  - Ausf√ºhrliche Competitive Research
  - Detailliertes Requirements Engineering
  - Sophisticated Business Case Development

### Claude Sonnet 4 - Optimale Phasen:
- **Phase 2-7:** Implementation & Deployment
  - Code-Development & Architecture
  - System-Integration & Testing
  - Performance-Optimierung
  - Production-Deployment

## üîß **Framework-Compliance-Features**

### Automatische Session-Validierung:
1. **Model-Detection:** Aktuelles Claude-Modell identifizieren
2. **Phase-Matching:** Optimal model f√ºr aktuelle Phase pr√ºfen
3. **User-Warning:** Bei Mismatch informative Warnung anzeigen
4. **Flexibility:** Fortsetzung mit expliziter Best√§tigung erlauben

# Claude-spezifische Implementation

## üß† Claude-Rollen-Spezialisierung (Bew√§hrt aus Praxis)

### Claude Sonnet (Struktur & Coordination)
- **Requirements Engineering**: User Stories, NFRs, Validierung
- **System Architecture**: Tech-Stack-Entscheidungen, Design-Patterns
- **Project Management**: Phase-Koordination, Status-Updates
- **Documentation**: Repository-Maintenance, Handover-Dokumente
- **Quality Assurance**: Code-Review, Testing, Standards-Compliance

### Claude Opus (Kreativit√§t & Implementation)
- **Domain Expertise**: Fachberatung f√ºr spezifische Anwendungsgebiete
- **Creative Problem-Solving**: Innovative L√∂sungsans√§tze, UX-Design
- **Code Development**: Implementation, Integration, Testing
- **User Experience**: Interface-Design, Usability-Optimization
- **Innovation**: Neue Patterns und Ans√§tze entwickeln

## üîÑ Context Window Management (Claude-spezifisch)

### Hybrid Chat + Claude Code Strategien
**Standard-Ansatz: Chat-Phasen (1-4) + Claude Code-Phasen (5-7)**
- **Chat-Sessions**: Phase 1-4 (Setup + Requirements) - Multi-Model-Conversations
- **Transfer**: Ergebnisse-Datei-Download ‚Üí Repository-Integration
- **Claude Code**: Phase 5-7 (Implementation + Testing) - Repository-basierte Umsetzung

**Chat-Phasen-Aufteilung**:
- **Phase 1**: Repository Setup - Sonnet (strukturierte Setup-Planung)
- **Phase 2**: Kickoff & Grundlagen - Opus (kreative Ideenentwicklung)
- **Phase 3**: Fachexperten-Workshop - Opus (Domain-Expertise)
- **Phase 4**: Business Requirements - Sonnet (strukturierte Requirements-Analyse)

**Claude Code-Phasen-Aufteilung**:
- **Phase 5**: Architektur + Debug-Konzept - System-Architekt-Rolle
- **Phase 6**: Implementation - Developer + Quality Reviewer-Rolle
- **Phase 7**: Testing + Handover - QA + Technical Writer-Rolle

**GitHub-gesteuerte DevOps-Instanzen**
- Universal-Prompt f√ºr jeden Chat mit GitHub-Status-Check
- Automatisches Phasen-Marking nach Abschluss
- Framework-Phase-Details aus Repository abrufen

## üéØ Phasen-spezifische Interaktions-Pr√§ferenzen

### Chat-Phasen (1-4): Kreative Unterst√ºtzung
- **User-Rolle**: Fokussiert bleiben bei Anwendungs-Beschreibung
- **Claude-Rolle**: Kreativ unterst√ºtzend, Anwendungskontext erweitern
- **Grenzen**: Nicht √ºberdenken mit zu fr√ºhen Fachexperten-Eins√§tzen
- **Model-Allocation**: Sonnet f√ºr Struktur (Phase 1,4), Opus f√ºr Kreativit√§t (Phase 2,3)
- **Output**: Strukturierte Ergebnisse-Datei f√ºr Claude Code Transfer

### Claude Code-Phasen (5-7): Strikt arbeiten
- **User-Rolle**: Klare Vorgaben und Abnahme-Kriterien
- **Claude Code-Rolle**: Keine Kreativit√§t, nur solide technische Umsetzung
- **Focus**: Funktionalit√§t und Qualit√§t vor Innovation
- **Input**: Chat-Ergebnisse als vollst√§ndige Arbeitsanweisungen
- **Output**: Production-ready Code im Repository

## üìã Claude-spezifische Handover-Templates

### Sonnet ‚Üí Opus Handover
```markdown
# Sonnet ‚Üí Opus Handover - Phase [X]

## Structural Analysis Complete
**Requirements**: [Link zu Requirements-Dokument im Repository]
**Architecture**: [Entscheidungen und Begr√ºndungen]
**Constraints**: [Technische und Business-Einschr√§nkungen]
**Repository-Status**: [Branch, Commit-Hash, Phase-Marker]

## Creative Brief f√ºr Opus
**Innovation-Potentiale**: [Bereiche f√ºr kreative L√∂sungen]
**UX-Fokus**: [User Experience Priorit√§ten]
**Implementation-Freiheiten**: [Wo Kreativit√§t erw√ºnscht ist]
**Technical-Boundaries**: [Was nicht ver√§ndert werden soll]

## Context-Transfer
**GitHub-Repository**: [Direkter Link mit Branch/Commit]
**Phase-Status**: Abgeschlossen - Ready for creative implementation
**Next-Steps**: [Konkrete n√§chste Aufgaben f√ºr Opus]
**Quality-Criteria**: [Was beachtet werden muss]
**Handover-Verification**: [Checkpunkte f√ºr erfolgreiche √úbergabe]
```

### Opus ‚Üí Sonnet Handover
```markdown
# Opus ‚Üí Sonnet Handover - Phase [X]

## Creative Solutions Developed
**Innovative Ans√§tze**: [Beschreibung kreativer L√∂sungen]
**Prototypes**: [Links zu Code/Mockups im Repository]
**UX-Decisions**: [Interface und Experience Entscheidungen]
**Technical-Innovations**: [Neue Patterns oder Ans√§tze]
**Repository-Updates**: [Was committed wurde]

## Review-Request f√ºr Sonnet
**Quality-Check**: [Was strukturell gepr√ºft werden soll]
**Code-Review**: [Performance, Standards, Best-Practices]
**Optimization**: [Bereiche f√ºr Verbesserung]
**Documentation**: [Was noch dokumentiert werden muss]
**Standards-Compliance**: [Framework-Konformit√§t pr√ºfen]

## Implementation-Details
**Code-Struktur**: [Architektur-Overview]
**Dependencies**: [Verwendete Libraries/APIs]
**Testing-Status**: [Was getestet, was noch offen]
**Deployment-Ready**: [Status f√ºr Production-Einsatz]
**Repository-Health**: [Commit-Status, Documentation-Coverage]
```

## üõ°Ô∏è Mathematische Validierung f√ºr Fachsoftware

### 3-Stufen-Validierung (Claude-optimiert)
1. **Claude-Formel-Verification**: KI pr√ºft mathematische Korrektheit gegen Referenzen
2. **Range-Checking**: Realistische Min/Max-Werte f√ºr Parameter definieren
3. **Cross-Validation**: Multiple Berechnungswege f√ºr kritische Werte implementieren
4. **Reference-Check**: Abgleich mit Fachquellen und Standards dokumentieren

### Haftungsausschluss-Integration (Standard f√ºr Fachsoftware)
```markdown
## Automatischer Haftungsausschluss f√ºr Fachsoftware
"Diese Software stellt Berechnungshilfen zur Verf√ºgung.
Vor produktivem Einsatz m√ºssen alle Ergebnisse durch
qualifiziertes Fachpersonal validiert werden.
Keine Haftung f√ºr Sch√§den durch fehlerhafte Berechnungen,
Implementierungsfehler oder unsachgem√§√üe Verwendung."
```

### Warning-System f√ºr kritische Parameter
```javascript
// Beispiel f√ºr automatische Warnungen bei gef√§hrlichen Werten
function validateParameter(value, min, max, paramName) {
    if (value < min || value > max) {
        console.warn(`‚ö†Ô∏è  WARNUNG: ${paramName} = ${value} au√üerhalb sicherer Grenzen [${min}, ${max}]`);
        return {valid: false, warning: `Parameter au√üerhalb Sicherheitsbereich`};
    }
    return {valid: true, warning: null};
}
```

## üéØ Claude-spezifische Prompt-Optimierungen

### Hybrid Session Starters

#### Chat Session Starter (Phase 1-4)
```markdown
## Meta AI Framework v1.0 - Chat-Phasen
**Framework**: Meta AI Development Framework v1.0 by Volker Hochg√ºrtel
**Meta-Profile**: https://github.com/VoHoch/meta-ai-interaction-profile
**Current Phase**: [1-4] von 7
**Model**: [Sonnet: Structure/Analysis | Opus: Creativity/Domain]
**Workflow-Mode**: Multi-Model Chat-Session
**Target**: Ergebnisse-Datei f√ºr Claude Code Transfer

**Quality Standards**: Enterprise-level specifications for SME applications
**Output-Requirement**: Strukturierte Deliverables f√ºr Repository-Implementation
```

#### Claude Code Session Starter (Phase 5-7)
```markdown
## Meta AI Framework v1.0 - Implementation-Phasen
**CLAUDE.md**: Auto-loaded ‚úì
**Input-File**: ergebnisse-phase-1-4-[projektname].md
**Current Phase**: [5-7] von 7
**Role**: System-Architect/Developer/QA
**Workflow-Mode**: Repository-based Implementation
**Target**: Production-ready Application

**Quality Standards**: All Chat-Phase requirements implemented
**Output-Requirement**: Committed code, documentation, tests in repository
```

## üö´ Claude Anti-Patterns (aus Session-Erfahrung dokumentiert)

### Information-Gathering Anti-Patterns
```
‚ùå CLAUDE ANTI-PATTERN 1: Vorzeitige Antworten ohne vollst√§ndige Informationen
   Beispiel: Framework erstellen ohne systematische Fragelisten-Bearbeitung
   L√∂sung: Immer vollst√§ndigkeits-Check vor Antwort-Generierung

‚ùå CLAUDE ANTI-PATTERN 2: Annahmen √ºber User-Priorit√§ten ohne R√ºckfrage
   Beispiel: CNC-spezifische Optimierung statt application-agnostic Framework
   L√∂sung: User-Pr√§ferenzen explizit abfragen, nicht vermuten

‚ùå CLAUDE ANTI-PATTERN 3: Strukturierte User-Prozesse √ºberspringen
   Beispiel: Frageliste √ºberspringen und direkt "loslegen"
   L√∂sung: User-Prozesse respektieren und systematisch befolgen

‚ùå CLAUDE ANTI-PATTERN 4: Erarbeitete Informationen beim Umstrukturieren wegwerfen
   Beispiel: Claude-spezifische Details beim "Universal AI"-Umbau verlieren
   L√∂sung: Information-Preservation - alle Details in entsprechende Abschnitte verschieben

‚ùå CLAUDE ANTI-PATTERN 5: Dateinamen-Inkonsistenzen
   Beispiel: Unterstriche vs. Bindestriche vs. Leerzeichen chaotisch mischen
   L√∂sung: Konsistente Naming-Convention durchgehend anwenden
```

### Success Patterns (bew√§hrt aus Praxis)
```
‚úÖ CLAUDE SUCCESS-PATTERN 1: Systematische Fragelisten vor L√∂sungsentwicklung
‚úÖ CLAUDE SUCCESS-PATTERN 2: Repository-basierte Dokumentation f√ºr Persistenz
‚úÖ CLAUDE SUCCESS-PATTERN 3: Meta-Level Reflexion √ºber Interaktionsprozesse
‚úÖ CLAUDE SUCCESS-PATTERN 4: Information-Preservation beim Framework-Umbau
‚úÖ CLAUDE SUCCESS-PATTERN 5: Strukturierte Handover-Prozesse zwischen Sessions
```

## üìê Claude-spezifische Interaktions-Regeln

```markdown
CLAUDE-REGEL 1: Context-Window-Bewusstsein
- Bei Chat-Wechsel: Vollst√§ndige Repository-Lekt√ºre vor Start
- Sonnet/Opus Rollenklarheit explizit vor Phase-Beginn deklarieren
- Handover-Dokumente als prim√§re Context-Quelle nutzen

CLAUDE-REGEL 2: Multi-Model-Koordination
- Sonnet f√ºr Struktur und Analyse, Opus f√ºr Kreativit√§t und Innovation
- Explizite Rollen-Deklaration in jeder Session
- Handover-Qualit√§t zwischen Models durch Templates sicherstellen

CLAUDE-REGEL 3: Repository-Integration
- Jede Phase vollst√§ndig dokumentiert committen
- GitHub-Status als Single Source of Truth behandeln
- Phase-Marker f√ºr Context-Continuation setzen
- Alle Artefakte versioniert im Repository ablegen

CLAUDE-REGEL 4: Qualit√§ts-Sicherstellung
- Enterprise-Standards auch f√ºr SME-Anwendungen anwenden
- Mathematische Validierung bei Fachsoftware implementieren
- Code-Review und Testing in Implementation-Phase integrieren
- User-Acceptance-Tests vor Projektabschluss durchf√ºhren
```